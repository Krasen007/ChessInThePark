<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <link rel="stylesheet" href="css/styles.css">
</head>

<body style="background: #f0f0f0;">
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title" id="game-title">Chess Game</h1>
            <div class="game-status" id="game-status">Loading...</div>

            <div class="player-info" id="player-info" style="display: none;">
                <div class="player" id="white-player">
                    <div>⚪ <span id="white-label">White</span></div>
                    <div id="white-name">Player 1</div>
                </div>
                <div class="player" id="black-player">
                    <div>⚫ <span id="black-label">Black</span></div>
                    <div id="black-name">Player 2</div>
                </div>
            </div>
        </div>

        <div class="chessboard-container">
            <div id="chessboard" class="simple-chessboard"></div>
            <div id="game-over-overlay" class="game-over-overlay">
                <div id="game-over-message" class="game-over-message"></div>
            </div>
        </div>

        <div class="game-controls">

            <button class="control-btn" id="home-btn" onclick="goHome()">
                <span id="home-text">Home</span>
            </button>
        </div>

        <div id="move-history" style="margin-top: 20px; text-align: center;">
            <h3 id="history-title">Move History</h3>
            <div id="history-list"
                style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin-top: 10px; border-radius: 5px;">
            </div>
        </div>
    </div>

    <!-- Load Socket.io from our server -->
    <script src="/socket.io/socket.io.js"></script>
    <!-- Load chess logic -->
    <script src="/js/chess-logic.js"></script>
    <!-- Simple Chess.js alternative -->
    <script>
        // Simple chess logic
        class SimpleChess {
            constructor() {
                this.board = this.getStartingPosition();
                this.turn = 'w';
                this.history = [];
                this.gameStatus = 'active'; // active, checkmate, stalemate
                this.check = false;
                this.lastMove = null;
                this.castlingRights = { K: true, Q: true, k: true, q: true };
                this.halfMoveClock = 0;
                this.positions = new Map(); // For threefold repetition
                this.pendingPromotion = null;
            }

            getStartingPosition() {
                return [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
                ];
            }

            getPiece(row, col) {
                return this.board[row][col];
            }

            setPiece(row, col, piece) {
                this.board[row][col] = piece;
            }

            isValidMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.getPiece(fromRow, fromCol);
                if (!piece) return false;

                // Check if it's the right player's turn
                const isWhite = piece === piece.toUpperCase();
                if ((isWhite && this.turn !== 'w') || (!isWhite && this.turn !== 'b')) {
                    return false;
                }

                // Use ChessRules to validate the move
                if (!ChessRules.isValidMove(piece, fromRow, fromCol, toRow, toCol, this.board)) {
                    return false;
                }

                // Test if move would leave king in check
                const tempPiece = this.board[toRow][toCol];
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;

                const inCheck = ChessRules.isInCheck(this.board, isWhite);

                // Undo test move
                this.board[fromRow][fromCol] = piece;
                this.board[toRow][toCol] = tempPiece;

                return !inCheck;
            }

            makeMove(fromRow, fromCol, toRow, toCol, promotionPiece = null) {
                if (this.pendingPromotion && !promotionPiece) {
                    return false;
                }

                let piece = this.getPiece(fromRow, fromCol);
                if (!piece) {
                    return false;
                }

                const isWhite = piece === piece.toUpperCase();
                const pieceType = piece.toLowerCase();
                const targetPiece = this.getPiece(toRow, toCol);

                if (!this.isValidMove(fromRow, fromCol, toRow, toCol)) {
                    return false;
                }

                // Update halfmove clock
                if (pieceType === 'p' || targetPiece) {
                    this.halfMoveClock = 0;
                } else {
                    this.halfMoveClock++;
                }

                // Handle castling
                if (pieceType === 'k' && Math.abs(toCol - fromCol) === 2) {
                    const row = isWhite ? 7 : 0;
                    const isKingside = toCol > fromCol;
                    
                    // First check if castling is allowed
                    const castlingSide = isKingside ? 'kingside' : 'queenside';
                    if (!ChessRules.canCastle(isWhite, castlingSide, this.board, this.castlingRights)) {
                        return false;
                    }

                    const rookFromCol = isKingside ? 7 : 0;
                    const rookToCol = isKingside ? 5 : 3;
                    const rook = isWhite ? 'R' : 'r';

                    // Move both the king and rook
                    this.setPiece(toRow, toCol, piece);
                    this.setPiece(fromRow, fromCol, null);
                    this.setPiece(row, rookToCol, rook);
                    this.setPiece(row, rookFromCol, null);
                    
                    // Update castling rights
                    if (isWhite) {
                        this.castlingRights.K = false;
                        this.castlingRights.Q = false;
                    } else {
                        this.castlingRights.k = false;
                        this.castlingRights.q = false;
                    }
                    
                    // Switch turns for castling
                    this.turn = this.turn === 'w' ? 'b' : 'w';

                    const move = {
                        from: this.positionToString(fromRow, fromCol),
                        to: this.positionToString(toRow, toCol),
                        piece: piece,
                        isCheck: false,
                        isCheckmate: false,
                        isStalemate: false,
                        isDraw: false
                    };

                    this.history.push(move);
                    return move;
                }

                // Handle en passant capture
                if (pieceType === 'p' && Math.abs(toCol - fromCol) === 1 && !targetPiece) {
                    const captureRow = isWhite ? toRow + 1 : toRow - 1;
                    this.setPiece(captureRow, toCol, null);
                }

                // Make the move
                this.setPiece(toRow, toCol, piece);
                this.setPiece(fromRow, fromCol, null);

                // Handle pawn promotion
                if (pieceType === 'p' && (toRow === 0 || toRow === 7)) {
                    // Make the initial pawn move
                    this.setPiece(toRow, toCol, piece);
                    this.setPiece(fromRow, fromCol, null);
                    
                    // Automatically promote to queen
                    const promotedPiece = isWhite ? 'Q' : 'q';
                    this.setPiece(toRow, toCol, promotedPiece);
                    piece = promotedPiece;  // Update piece for move history
                    
                    // Update game state
                    this.lastMove = [fromRow, fromCol, toRow, toCol];
                    const position = this.getBoardFEN();
                    this.positions.set(position, (this.positions.get(position) || 0) + 1);
                    
                    // Switch turns
                    this.turn = this.turn === 'w' ? 'b' : 'w';
                    
                    // Create and return the move object
                    const move = {
                        from: this.positionToString(fromRow, fromCol),
                        to: this.positionToString(toRow, toCol),
                        piece: piece,
                        isCheck: this.check,
                        isCheckmate: this.gameStatus === 'checkmate',
                        isStalemate: this.gameStatus === 'stalemate',
                        isDraw: this.gameStatus.startsWith('draw-'),
                        promotedTo: promotedPiece
                    };
                    this.history.push(move);
                    return move;
                }

                // Update castling rights
                if (pieceType === 'k') {
                    if (isWhite) {
                        this.castlingRights.K = false;
                        this.castlingRights.Q = false;
                    } else {
                        this.castlingRights.k = false;
                        this.castlingRights.q = false;
                    }
                } else if (pieceType === 'r') {
                    if (fromRow === 7 && fromCol === 0) this.castlingRights.Q = false;
                    if (fromRow === 7 && fromCol === 7) this.castlingRights.K = false;
                    if (fromRow === 0 && fromCol === 0) this.castlingRights.q = false;
                    if (fromRow === 0 && fromCol === 7) this.castlingRights.k = false;
                }

                // Store last move for en passant
                this.lastMove = [fromRow, fromCol, toRow, toCol];

                // Update position history for threefold repetition
                const position = this.getBoardFEN();
                this.positions.set(position, (this.positions.get(position) || 0) + 1);

                // Switch turns
                this.turn = this.turn === 'w' ? 'b' : 'w';

                // Check game status
                const nextIsWhite = this.turn === 'w';
                this.check = ChessRules.isInCheck(this.board, nextIsWhite);

                // Check for game end conditions
                if (!ChessRules.hasLegalMoves(this.board, nextIsWhite)) {
                    if (this.check) {
                        this.gameStatus = 'checkmate';
                    } else {
                        this.gameStatus = 'stalemate';
                    }
                } else if (this.halfMoveClock >= 100) {
                    this.gameStatus = 'draw-fifty';
                } else if (this.isThreefoldRepetition()) {
                    this.gameStatus = 'draw-repetition';
                }

                const move = {
                    from: this.positionToString(fromRow, fromCol),
                    to: this.positionToString(toRow, toCol),
                    piece: piece,
                    isCheck: this.check,
                    isCheckmate: this.gameStatus === 'checkmate',
                    isStalemate: this.gameStatus === 'stalemate',
                    isDraw: this.gameStatus.startsWith('draw-'),
                    promotedTo: promotionPiece
                };

                this.history.push(move);
                return move;
            }

            positionToString(row, col) {
                return String.fromCharCode(97 + col) + (8 - row);
            }

            stringToPosition(pos) {
                if (!pos || typeof pos !== 'string' || pos.length !== 2) return null;
                const col = pos.charCodeAt(0) - 97;
                const row = 8 - parseInt(pos[1]);
                // Validate coordinates are within board bounds
                if (row < 0 || row > 7 || col < 0 || col > 7) return null;
                return [row, col];
            }

            getBoardFEN() {
                let fen = '';
                for (let row = 0; row < 8; row++) {
                    let emptyCount = 0;
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            if (emptyCount > 0) {
                                fen += emptyCount;
                                emptyCount = 0;
                            }
                            fen += piece;
                        } else {
                            emptyCount++;
                        }
                    }
                    if (emptyCount > 0) {
                        fen += emptyCount;
                    }
                    if (row < 7) fen += '/';
                }
                return fen;
            }

            isThreefoldRepetition() {
                const currentPosition = this.getBoardFEN();
                return this.positions.get(currentPosition) >= 3;
            }

            reset() {
                this.board = this.getStartingPosition();
                this.turn = 'w';
                this.history = [];
                this.gameStatus = 'active';
                this.check = false;
                this.lastMove = null;
                this.castlingRights = { K: true, Q: true, k: true, q: true };
                this.halfMoveClock = 0;
                this.positions = new Map();
                this.pendingPromotion = null;
            }
        }

        // Piece symbols
        const pieceSymbols = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };
    </script>

    <script>
        // Language translations
        const translations = {
            en: {
                gameTitle: 'Chess Game',
                singlePlayerTitle: 'Single Player Chess',
                multiplayerTitle: 'Multiplayer Chess',
                waitingForOpponent: 'Waiting for opponent...',
                gameStarted: 'Game started! Your turn.',
                opponentTurn: "Opponent's turn",
                yourTurn: 'Your turn',
                whitesTurn: "White's turn",
                blacksTurn: "Black's turn",
                whiteWins: 'White wins by checkmate!',
                blackWins: 'Black wins by checkmate!',
                stalemate: 'Game drawn by stalemate!',
                drawRepetition: 'Game drawn by threefold repetition!',
                drawFifty: 'Game drawn by fifty-move rule!',
                check: 'Check!',
                opponentLeft: 'Opponent left the game',
                newGame: 'New Game',
                home: 'Home',
                white: 'White',
                black: 'Black',
                historyTitle: 'Move History',
                lobbyFull: 'Game lobby is full. Please try again later.',
                connectionError: 'Connection error. Please refresh the page.'
            },
            bg: {
                gameTitle: 'Шахматна игра',
                singlePlayerTitle: 'Шахмат за един играч',
                multiplayerTitle: 'Шахмат за много играчи',
                waitingForOpponent: 'Чакане на противник...',
                gameStarted: 'Играта започна! Вашият ред.',
                opponentTurn: 'Ред на противника',
                yourTurn: 'Вашият ред',
                whitesTurn: 'Ред на белите',
                blacksTurn: 'Ред на черните',
                whiteWins: 'Белите печелят!',
                blackWins: 'Черните печелят!',
                opponentLeft: 'Противникът напусна играта',
                newGame: 'Нова игра',
                home: 'Начало',
                white: 'Бели',
                black: 'Черни',
                historyTitle: 'История на ходовете',
                lobbyFull: 'Лобито е пълно. Моля, опитайте отново по-късно.',
                connectionError: 'Грешка във връзката. Моля, обновете страницата.'
            }
        };

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const gameMode = urlParams.get('mode') || 'single';
        const currentLang = urlParams.get('lang') || 'en';
        const t = translations[currentLang];

        // Game variables
        let game = new SimpleChess();
        let socket = null;
        let playerColor = null;
        let gameStarted = false;
        let selectedSquare = null;

        // Initialize the application
        function init() {
            updateLanguage();
            createBoard();

            // Initialize game mode specific functionality
            if (gameMode === 'multiplayer') {
                document.getElementById('player-info').style.display = 'none';
                setBoardEnabled(false);
                initMultiplayer();
            } else {
                initSinglePlayer();
            }
        }

        // Update page language
        function updateLanguage() {
            document.documentElement.lang = currentLang;
            document.getElementById('game-title').textContent =
                gameMode === 'multiplayer' ? t.multiplayerTitle : t.singlePlayerTitle;
            document.getElementById('home-text').textContent = t.home;
            document.getElementById('white-label').textContent = t.white;
            document.getElementById('black-label').textContent = t.black;
            document.getElementById('history-title').textContent = t.historyTitle;
        }

        // Create the chess board
        function createBoard() {
            const board = document.getElementById('chessboard');
            board.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `chess-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.addEventListener('click', onSquareClick);

                    const piece = game.getPiece(row, col);
                    if (piece) {
                        square.textContent = pieceSymbols[piece] || piece;
                    }

                    board.appendChild(square);
                }
            }
        }

        // Enable or disable the chessboard (for multiplayer waiting state)
        function setBoardEnabled(enabled) {
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(square => {
                square.style.pointerEvents = enabled ? 'auto' : 'none';
                square.style.opacity = enabled ? '1' : '0.5';
            });
        }

        // Handle square clicks
        function onSquareClick(event) {
            if (!gameStarted) return;

            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);

            // In multiplayer, check if it's our turn
            if (gameMode === 'multiplayer' && playerColor) {
                const isWhiteTurn = game.turn === 'w';
                const isMyTurn = (isWhiteTurn && playerColor === 'white') || (!isWhiteTurn && playerColor === 'black');
                if (!isMyTurn) return;
            }

            if (selectedSquare) {
                // Try to make a move
                const fromRow = selectedSquare.row;
                const fromCol = selectedSquare.col;

                if (fromRow === row && fromCol === col) {
                    // Clicked same square - deselect
                    clearSelection();
                    return;
                }

                const move = game.makeMove(fromRow, fromCol, row, col);
                if (move) {
                    updateStatus(move);
                    updateBoard();
                    addToHistory(`${move.from}-${move.to}`);

                    // Send move in multiplayer
                    if (gameMode === 'multiplayer' && socket) {
                        socket.emit('make-move', {
                            from: move.from,
                            to: move.to,
                            piece: game.getPiece(row, col),
                            isCheck: move.isCheck,
                            isCheckmate: game.gameStatus === 'checkmate',
                            isStalemate: game.gameStatus === 'stalemate',
                            isDraw: game.gameStatus.startsWith('draw-'),
                            gameStatus: game.gameStatus,
                            fen: 'simple-chess-state'
                        });
                    }

                    updateStatus();
                }

                clearSelection();
            } else {
                // Select a piece
                const piece = game.getPiece(row, col);
                if (piece) {
                    selectedSquare = { row, col };
                    event.target.classList.add('selected');
                }
            }
        }

        // Clear selection
        function clearSelection() {
            document.querySelectorAll('.chess-square').forEach(square => {
                square.classList.remove('selected', 'highlight');
            });
            selectedSquare = null;
        }

        // Update board display
        function updateBoard() {
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach((square, index) => {
                const row = Math.floor(index / 8);
                const col = index % 8;
                const piece = game.getPiece(row, col);
                square.textContent = piece ? (pieceSymbols[piece] || piece) : '';
            });
        }

        // Initialize single player mode
        function initSinglePlayer() {
            document.getElementById('game-status').textContent = t.whitesTurn;
            document.getElementById('game-status').className = 'game-status status-playing';
            document.getElementById('player-info').style.display = 'flex';
            gameStarted = true;
            updateStatus();
        }

        // Initialize multiplayer mode
        function initMultiplayer() {
            document.getElementById('game-status').textContent = t.waitingForOpponent;
            document.getElementById('game-status').className = 'game-status status-waiting';

            // Connect to server with specific configuration
            socket = io({
                reconnectionAttempts: 3,
                reconnectionDelay: 1000,
                timeout: 5000
            });

            // Socket event handlers
            socket.on('waiting-for-opponent', () => {
                document.getElementById('game-status').textContent = t.waitingForOpponent;
                document.getElementById('game-status').className = 'game-status status-waiting';
                setBoardEnabled(false);
                document.getElementById('player-info').style.display = 'none';
            });

            socket.on('game-start', (data) => {
                gameStarted = true;
                playerColor = data.players.find(p => p.id === socket.id).color;

                document.getElementById('player-info').style.display = 'flex';
                document.getElementById('white-name').textContent = playerColor === 'white' ? 'You' : 'Opponent';
                document.getElementById('black-name').textContent = playerColor === 'black' ? 'You' : 'Opponent';

                setBoardEnabled(true);
                updateStatus();
            });

            socket.on('move-update', (moveData) => {
                if (!moveData || !moveData.from || !moveData.to) return;

                // Convert coordinates and validate
                const fromPos = game.stringToPosition(moveData.from);
                const toPos = game.stringToPosition(moveData.to);

                if (!fromPos || !toPos) return;

                // Validate that there is a piece at the from position
                if (!game.getPiece(fromPos[0], fromPos[1])) return;

                const [fromRow, fromCol] = fromPos;
                const [toRow, toCol] = toPos;

                // Make the move and get the result
                const move = game.makeMove(fromRow, fromCol, toRow, toCol, moveData.promotedTo);
                if (!move) return;

                // Synchronize game state with server
                move.isCheck = moveData.isCheck;
                move.isCheckmate = moveData.isCheckmate;
                move.isStalemate = moveData.isStalemate;
                move.isDraw = moveData.isDraw;
                move.gameStatus = moveData.gameStatus;

                // Update the game state
                game.check = moveData.isCheck;
                game.gameStatus = moveData.isCheckmate ? 'checkmate' :
                    moveData.isStalemate ? 'stalemate' :
                        moveData.isDraw ? moveData.gameStatus :
                            'active';

                // Update the UI
                updateBoard();
                addToHistory(`${moveData.from}-${moveData.to}`);
                updateStatus(move);
            });

            socket.on('opponent-left', () => {
                document.getElementById('game-status').textContent = t.opponentLeft;
                document.getElementById('game-status').className = 'game-status status-ended';
                gameStarted = false;
            });

            socket.on('lobby-full', () => {
                document.getElementById('game-status').textContent = t.lobbyFull;
                document.getElementById('game-status').className = 'game-status status-ended';
            });

            let reconnectAttempts = 0;
            const maxReconnectAttempts = 3;

            socket.on('connect_error', () => {
                reconnectAttempts++;
                document.getElementById('game-status').textContent = reconnectAttempts < maxReconnectAttempts ?
                    `${t.connectionError} Retrying... (${reconnectAttempts}/${maxReconnectAttempts})` :
                    `${t.connectionError} Please refresh the page when the server is back online.`;
                document.getElementById('game-status').className = 'game-status status-ended';

                if (reconnectAttempts >= maxReconnectAttempts) {
                    socket.close();
                    gameStarted = false;
                    document.getElementById('game-over-overlay').style.display = 'flex';
                    document.getElementById('game-over-message').textContent = 'Server connection lost. Please refresh when the server is back online.';
                }
            });

            socket.on('connect', () => {
                reconnectAttempts = 0;
                // Only join lobby if not already in a game
                if (!gameStarted) {
                    socket.emit('join-lobby');
                }
            });

            // Do not emit join-lobby here; it is handled in the 'connect' event
        }

        // Update game status
        function updateStatus(moveResult) {
            let status = '';
            let statusClass = 'status-playing';
            const overlay = document.getElementById('game-over-overlay');
            const messageEl = document.getElementById('game-over-message');

            // Handle game end conditions first
            if (moveResult) {
                if (moveResult.isCheckmate) {
                    status = game.turn === 'b' ? t.whiteWins : t.blackWins;
                    statusClass = 'status-ended';
                    messageEl.textContent = status;
                    overlay.style.display = 'flex';
                } else if (moveResult.isStalemate) {
                    status = t.stalemate;
                    statusClass = 'status-ended';
                    messageEl.textContent = status;
                    overlay.style.display = 'flex';
                } else if (moveResult.isDraw) {
                    status = moveResult.gameStatus === 'draw-repetition' ?
                        t.drawRepetition : t.drawFifty;
                    statusClass = 'status-ended';
                    messageEl.textContent = status;
                    overlay.style.display = 'flex';
                } else if (moveResult.isCheck) {
                    status = t.check;
                    statusClass = 'status-check';
                }
            }

            // If game is still active, show regular turn status
            if (!status) {
                // Check if the current player is in check
                if (game.check) {
                    status = t.check;
                    statusClass = 'status-check';
                } else {
                    if (gameMode === 'multiplayer' && gameStarted && playerColor) {
                        const isMyTurn = (game.turn === 'w' && playerColor === 'white') ||
                            (game.turn === 'b' && playerColor === 'black');
                        status = isMyTurn ? t.yourTurn : t.opponentTurn;
                    } else if (gameMode === 'single') {
                        status = game.turn === 'w' ? t.whitesTurn : t.blacksTurn;
                    }
                }
            }

            // Update the status display
            const statusElement = document.getElementById('game-status');
            statusElement.textContent = status;
            statusElement.className = `game-status ${statusClass}`;

            // Update active player highlight
            if (gameStarted) {
                document.getElementById('white-player').classList.toggle('active', game.turn === 'w');
                document.getElementById('black-player').classList.toggle('active', game.turn === 'b');
            }
        }

        // Add move to history
        function addToHistory(move) {
            const historyList = document.getElementById('history-list');
            const moveNumber = Math.ceil(game.history.length / 2);
            const isWhiteMove = game.turn === 'b';

            if (isWhiteMove) {
                const moveElement = document.createElement('div');
                moveElement.textContent = `${moveNumber}. ${move}`;
                moveElement.style.padding = '2px 5px';
                moveElement.style.borderBottom = '1px solid #eee';
                historyList.appendChild(moveElement);
            } else {
                const lastMoveElement = historyList.lastElementChild;
                if (lastMoveElement) {
                    lastMoveElement.textContent += ` ${move}`;
                }
            }
            historyList.scrollTop = historyList.scrollHeight;
        }

        // Start new game
        function startNewGame() {
            game.reset();
            clearSelection();
            document.getElementById('history-list').innerHTML = '';
            document.getElementById('game-over-overlay').style.display = 'none';
            createBoard();

            if (gameMode === 'multiplayer') {
                if (socket) {
                    socket.emit('leave-game');  // Explicitly tell server we're leaving
                    socket.disconnect();
                    socket = null;
                }
                // Reset game state
                gameStarted = false;
                playerColor = null;
                // Hide player info and disable board until game starts
                document.getElementById('player-info').style.display = 'none';
                setBoardEnabled(false);
                // Create new socket connection
                socket = io({
                    reconnectionAttempts: 3,
                    reconnectionDelay: 1000,
                    timeout: 5000,
                    forceNew: true  // Force a new connection
                });
                initMultiplayer();
            } else {
                gameStarted = true;
                updateStatus();
            }
        }

        // Go to home page
        function goHome() {
            if (socket) {
                socket.emit('leave-game');  // Explicitly tell server we're leaving
                socket.disconnect();
                socket = null;
            }
            window.location.href = `/?lang=${currentLang}`;
        }

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (socket) {
                socket.emit('leave-game');  // Explicitly tell server we're leaving
                socket.disconnect();
                socket = null;
            }
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>

</html>