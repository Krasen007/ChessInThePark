<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        /* Simple chess board CSS */
        .simple-chessboard {
            width: 400px;
            height: 400px;
            border: 3px solid #333;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            margin: 0 auto;
        }
        .chess-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            cursor: pointer;
            user-select: none;
        }
        .chess-square.light { background-color: #f0d9b5; }
        .chess-square.dark { background-color: #b58863; }
        .chess-square.selected { background-color: #ffff00 !important; }
        .chess-square.highlight { background-color: #90ee90 !important; }
        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }
        .game-over-message {
            background-color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            text-align: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .chessboard-container {
            position: relative;
        }
        .status-ended {
            color: #d63031;
            font-weight: bold;
        }
        .player.active {
            background-color: #e8f5e9;
            border-radius: 5px;
            padding: 5px;
            box-shadow: 0 0 5px rgba(0,128,0,0.3);
        }
        }
    </style>
</head>
<body style="background: #f0f0f0;">
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title" id="game-title">Chess Game</h1>
            <div class="game-status" id="game-status">Loading...</div>
            
            <div class="player-info" id="player-info" style="display: none;">
                <div class="player" id="white-player">
                    <div>⚪ <span id="white-label">White</span></div>
                    <div id="white-name">Player 1</div>
                </div>
                <div class="player" id="black-player">
                    <div>⚫ <span id="black-label">Black</span></div>
                    <div id="black-name">Player 2</div>
                </div>
            </div>
        </div>

        <div class="chessboard-container">
            <div id="chessboard" class="simple-chessboard"></div>
            <div id="game-over-overlay" class="game-over-overlay">
                <div id="game-over-message" class="game-over-message"></div>
            </div>
        </div>

        <div class="game-controls">
            <button class="control-btn" id="new-game-btn" onclick="startNewGame()">
                <span id="new-game-text">New Game</span>
            </button>
            <button class="control-btn" id="home-btn" onclick="goHome()">
                <span id="home-text">Home</span>
            </button>
        </div>

        <div id="move-history" style="margin-top: 20px; text-align: center;">
            <h3 id="history-title">Move History</h3>
            <div id="history-list" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin-top: 10px; border-radius: 5px;"></div>
        </div>
    </div>

    <!-- Load Socket.io from our server -->
    <script src="/socket.io/socket.io.js"></script>
    <!-- Load chess logic -->
    <script src="/js/chess-logic.js"></script>
    <!-- Simple Chess.js alternative -->
    <script>
        // Simple chess logic
        class SimpleChess {
            constructor() {
                this.board = this.getStartingPosition();
                this.turn = 'w';
                this.history = [];
                this.gameStatus = 'active'; // active, checkmate, stalemate
                this.check = false;
                this.lastMove = null;
                this.castlingRights = { K: true, Q: true, k: true, q: true };
                this.halfMoveClock = 0;
                this.positions = new Map(); // For threefold repetition
                this.pendingPromotion = null;
            }
            
            getStartingPosition() {
                return [
                    ['r','n','b','q','k','b','n','r'],
                    ['p','p','p','p','p','p','p','p'],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    ['P','P','P','P','P','P','P','P'],
                    ['R','N','B','Q','K','B','N','R']
                ];
            }
            
            getPiece(row, col) {
                return this.board[row][col];
            }
            
            setPiece(row, col, piece) {
                this.board[row][col] = piece;
            }
            
            isValidMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.getPiece(fromRow, fromCol);
                if (!piece) return false;
                
                // Check if it's the right player's turn
                const isWhite = piece === piece.toUpperCase();
                if ((isWhite && this.turn !== 'w') || (!isWhite && this.turn !== 'b')) {
                    return false;
                }

                // Use ChessRules to validate the move
                if (!ChessRules.isValidMove(piece, fromRow, fromCol, toRow, toCol, this.board)) {
                    return false;
                }

                // Test if move would leave king in check
                const tempPiece = this.board[toRow][toCol];
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;

                const inCheck = ChessRules.isInCheck(this.board, isWhite);

                // Undo test move
                this.board[fromRow][fromCol] = piece;
                this.board[toRow][toCol] = tempPiece;

                return !inCheck;
            }
            
            makeMove(fromRow, fromCol, toRow, toCol, promotionPiece = null) {
                if (this.pendingPromotion && !promotionPiece) {
                    return false;
                }

                const piece = this.getPiece(fromRow, fromCol);
                const isWhite = piece === piece.toUpperCase();
                const pieceType = piece.toLowerCase();
                const targetPiece = this.getPiece(toRow, toCol);

                if (!this.isValidMove(fromRow, fromCol, toRow, toCol)) {
                    return false;
                }

                // Update halfmove clock
                if (pieceType === 'p' || targetPiece) {
                    this.halfMoveClock = 0;
                } else {
                    this.halfMoveClock++;
                }

                // Handle castling
                if (pieceType === 'k' && Math.abs(toCol - fromCol) === 2) {
                    const row = isWhite ? 7 : 0;
                    const isKingside = toCol > fromCol;
                    const rookFromCol = isKingside ? 7 : 0;
                    const rookToCol = isKingside ? 5 : 3;
                    
                    // Move rook
                    this.setPiece(row, rookToCol, isWhite ? 'R' : 'r');
                    this.setPiece(row, rookFromCol, null);
                }

                // Handle en passant capture
                if (pieceType === 'p' && Math.abs(toCol - fromCol) === 1 && !targetPiece) {
                    const captureRow = isWhite ? toRow + 1 : toRow - 1;
                    this.setPiece(captureRow, toCol, null);
                }

                // Make the move
                this.setPiece(toRow, toCol, piece);
                this.setPiece(fromRow, fromCol, null);

                // Handle pawn promotion
                if (pieceType === 'p' && (toRow === 0 || toRow === 7)) {
                    if (promotionPiece) {
                        const promotedPiece = isWhite ? promotionPiece.toUpperCase() : promotionPiece.toLowerCase();
                        this.setPiece(toRow, toCol, promotedPiece);
                        this.pendingPromotion = null;
                    } else {
                        this.pendingPromotion = { row: toRow, col: toCol, isWhite };
                        return { needsPromotion: true };
                    }
                }

                // Update castling rights
                if (pieceType === 'k') {
                    if (isWhite) {
                        this.castlingRights.K = false;
                        this.castlingRights.Q = false;
                    } else {
                        this.castlingRights.k = false;
                        this.castlingRights.q = false;
                    }
                } else if (pieceType === 'r') {
                    if (fromRow === 7 && fromCol === 0) this.castlingRights.Q = false;
                    if (fromRow === 7 && fromCol === 7) this.castlingRights.K = false;
                    if (fromRow === 0 && fromCol === 0) this.castlingRights.q = false;
                    if (fromRow === 0 && fromCol === 7) this.castlingRights.k = false;
                }

                // Store last move for en passant
                this.lastMove = [fromRow, fromCol, toRow, toCol];

                // Update position history for threefold repetition
                const position = this.getBoardFEN();
                this.positions.set(position, (this.positions.get(position) || 0) + 1);

                // Switch turns
                this.turn = this.turn === 'w' ? 'b' : 'w';
                
                // Check game status
                const nextIsWhite = this.turn === 'w';
                this.check = ChessRules.isInCheck(this.board, nextIsWhite);
                
                // Check for game end conditions
                if (!ChessRules.hasLegalMoves(this.board, nextIsWhite)) {
                    if (this.check) {
                        this.gameStatus = 'checkmate';
                    } else {
                        this.gameStatus = 'stalemate';
                    }
                } else if (this.halfMoveClock >= 100) {
                    this.gameStatus = 'draw-fifty';
                } else if (this.isThreefoldRepetition()) {
                    this.gameStatus = 'draw-repetition';
                }
                
                const move = {
                    from: this.positionToString(fromRow, fromCol),
                    to: this.positionToString(toRow, toCol),
                    piece: piece,
                    isCheck: this.check,
                    isCheckmate: this.gameStatus === 'checkmate',
                    isStalemate: this.gameStatus === 'stalemate',
                    isDraw: this.gameStatus.startsWith('draw-'),
                    promotedTo: promotionPiece
                };
                
                this.history.push(move);
                return move;
            }
            
            positionToString(row, col) {
                return String.fromCharCode(97 + col) + (8 - row);
            }
            
            stringToPosition(pos) {
                const col = pos.charCodeAt(0) - 97;
                const row = 8 - parseInt(pos[1]);
                return [row, col];
            }
            
            getBoardFEN() {
                let fen = '';
                for (let row = 0; row < 8; row++) {
                    let emptyCount = 0;
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            if (emptyCount > 0) {
                                fen += emptyCount;
                                emptyCount = 0;
                            }
                            fen += piece;
                        } else {
                            emptyCount++;
                        }
                    }
                    if (emptyCount > 0) {
                        fen += emptyCount;
                    }
                    if (row < 7) fen += '/';
                }
                return fen;
            }

            isThreefoldRepetition() {
                const currentPosition = this.getBoardFEN();
                return this.positions.get(currentPosition) >= 3;
            }

            reset() {
                this.board = this.getStartingPosition();
                this.turn = 'w';
                this.history = [];
                this.gameStatus = 'active';
                this.check = false;
                this.lastMove = null;
                this.castlingRights = { K: true, Q: true, k: true, q: true };
                this.halfMoveClock = 0;
                this.positions = new Map();
                this.pendingPromotion = null;
            }
        }
        
        // Piece symbols
        const pieceSymbols = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };
    </script>

    <script>
        // Language translations
        const translations = {
            en: {
                gameTitle: 'Chess Game',
                singlePlayerTitle: 'Single Player Chess',
                multiplayerTitle: 'Multiplayer Chess',
                waitingForOpponent: 'Waiting for opponent...',
                gameStarted: 'Game started! Your turn.',
                opponentTurn: "Opponent's turn",
                yourTurn: 'Your turn',
                whitesTurn: "White's turn",
                blacksTurn: "Black's turn",
                whiteWins: 'White wins by checkmate!',
                blackWins: 'Black wins by checkmate!',
                stalemate: 'Game drawn by stalemate!',
                drawRepetition: 'Game drawn by threefold repetition!',
                drawFifty: 'Game drawn by fifty-move rule!',
                check: 'Check!',
                opponentLeft: 'Opponent left the game',
                newGame: 'New Game',
                home: 'Home',
                white: 'White',
                black: 'Black',
                historyTitle: 'Move History',
                lobbyFull: 'Game lobby is full. Please try again later.',
                connectionError: 'Connection error. Please refresh the page.'
            },
            bg: {
                gameTitle: 'Шахматна игра',
                singlePlayerTitle: 'Шахмат за един играч',
                multiplayerTitle: 'Шахмат за много играчи',
                waitingForOpponent: 'Чакане на противник...',
                gameStarted: 'Играта започна! Вашият ред.',
                opponentTurn: 'Ред на противника',
                yourTurn: 'Вашият ред',
                whitesTurn: 'Ред на белите',
                blacksTurn: 'Ред на черните',
                whiteWins: 'Белите печелят!',
                blackWins: 'Черните печелят!',
                opponentLeft: 'Противникът напусна играта',
                newGame: 'Нова игра',
                home: 'Начало',
                white: 'Бели',
                black: 'Черни',
                historyTitle: 'История на ходовете',
                lobbyFull: 'Лобито е пълно. Моля, опитайте отново по-късно.',
                connectionError: 'Грешка във връзката. Моля, обновете страницата.'
            }
        };

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const gameMode = urlParams.get('mode') || 'single';
        const currentLang = urlParams.get('lang') || 'en';
        const t = translations[currentLang];

        // Game variables
        let game = new SimpleChess();
        let socket = null;
        let playerColor = null;
        let gameStarted = false;
        let selectedSquare = null;

        // Initialize the application
        function init() {
            updateLanguage();
            createBoard();
            
            if (gameMode === 'multiplayer') {
                initMultiplayer();
            } else {
                initSinglePlayer();
            }
        }

        // Update page language
        function updateLanguage() {
            document.documentElement.lang = currentLang;
            document.getElementById('game-title').textContent = 
                gameMode === 'multiplayer' ? t.multiplayerTitle : t.singlePlayerTitle;
            document.getElementById('new-game-text').textContent = t.newGame;
            document.getElementById('home-text').textContent = t.home;
            document.getElementById('white-label').textContent = t.white;
            document.getElementById('black-label').textContent = t.black;
            document.getElementById('history-title').textContent = t.historyTitle;
        }

        // Create the chess board
        function createBoard() {
            const board = document.getElementById('chessboard');
            board.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `chess-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.addEventListener('click', onSquareClick);
                    
                    const piece = game.getPiece(row, col);
                    if (piece) {
                        square.textContent = pieceSymbols[piece] || piece;
                    }
                    
                    board.appendChild(square);
                }
            }
        }

        // Handle square clicks
        function onSquareClick(event) {
            if (!gameStarted) return;
            
            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);
            
            // In multiplayer, check if it's our turn
            if (gameMode === 'multiplayer' && playerColor) {
                const isWhiteTurn = game.turn === 'w';
                const isMyTurn = (isWhiteTurn && playerColor === 'white') || (!isWhiteTurn && playerColor === 'black');
                if (!isMyTurn) return;
            }
            
            if (selectedSquare) {
                // Try to make a move
                const fromRow = selectedSquare.row;
                const fromCol = selectedSquare.col;
                
                if (fromRow === row && fromCol === col) {
                    // Clicked same square - deselect
                    clearSelection();
                    return;
                }
                
                const move = game.makeMove(fromRow, fromCol, row, col);
                if (move) {
                    updateStatus(move);
                    updateBoard();
                    addToHistory(`${move.from}-${move.to}`);
                    
                    // Send move in multiplayer
                    if (gameMode === 'multiplayer' && socket) {
                        socket.emit('make-move', {
                            from: move.from,
                            to: move.to,
                            fen: 'simple-chess-state' // We don't use FEN in our simple version
                        });
                    }
                    
                    updateStatus();
                }
                
                clearSelection();
            } else {
                // Select a piece
                const piece = game.getPiece(row, col);
                if (piece) {
                    selectedSquare = { row, col };
                    event.target.classList.add('selected');
                }
            }
        }

        // Clear selection
        function clearSelection() {
            document.querySelectorAll('.chess-square').forEach(square => {
                square.classList.remove('selected', 'highlight');
            });
            selectedSquare = null;
        }

        // Update board display
        function updateBoard() {
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach((square, index) => {
                const row = Math.floor(index / 8);
                const col = index % 8;
                const piece = game.getPiece(row, col);
                square.textContent = piece ? (pieceSymbols[piece] || piece) : '';
            });
        }

        // Initialize single player mode
        function initSinglePlayer() {
            document.getElementById('game-status').textContent = t.whitesTurn;
            document.getElementById('game-status').className = 'game-status status-playing';
            document.getElementById('player-info').style.display = 'flex';
            gameStarted = true;
            updateStatus();
        }

        // Initialize multiplayer mode
        function initMultiplayer() {
            document.getElementById('game-status').textContent = t.waitingForOpponent;
            document.getElementById('game-status').className = 'game-status status-waiting';
            
            // Connect to server
            socket = io();
            
            // Socket event handlers
            socket.on('waiting-for-opponent', () => {
                document.getElementById('game-status').textContent = t.waitingForOpponent;
                document.getElementById('game-status').className = 'game-status status-waiting';
            });

            socket.on('game-start', (data) => {
                gameStarted = true;
                playerColor = data.players.find(p => p.id === socket.id).color;
                
                document.getElementById('player-info').style.display = 'flex';
                document.getElementById('white-name').textContent = playerColor === 'white' ? 'You' : 'Opponent';
                document.getElementById('black-name').textContent = playerColor === 'black' ? 'You' : 'Opponent';
                
                updateStatus();
            });

            socket.on('opponent-move', (moveData) => {
                // Convert back to row/col and make the move
                const [fromRow, fromCol] = game.stringToPosition(moveData.from);
                const [toRow, toCol] = game.stringToPosition(moveData.to);
                
                game.makeMove(fromRow, fromCol, toRow, toCol);
                updateBoard();
                addToHistory(`${moveData.from}-${moveData.to}`);
                updateStatus();
            });

            socket.on('opponent-left', () => {
                document.getElementById('game-status').textContent = t.opponentLeft;
                document.getElementById('game-status').className = 'game-status status-ended';
                gameStarted = false;
            });

            socket.on('lobby-full', () => {
                document.getElementById('game-status').textContent = t.lobbyFull;
                document.getElementById('game-status').className = 'game-status status-ended';
            });

            socket.on('connect_error', () => {
                document.getElementById('game-status').textContent = t.connectionError;
                document.getElementById('game-status').className = 'game-status status-ended';
            });

            // Join the multiplayer lobby
            socket.emit('join-lobby');
        }

        // Update game status
        function updateStatus(moveResult) {
            let status = '';
            let statusClass = 'status-playing';
            const overlay = document.getElementById('game-over-overlay');
            const messageEl = document.getElementById('game-over-message');

            // Handle game end conditions first
            if (moveResult) {
                if (moveResult.isCheckmate) {
                    status = game.turn === 'b' ? t.whiteWins : t.blackWins;
                    statusClass = 'status-ended';
                    messageEl.textContent = status;
                    overlay.style.display = 'flex';
                } else if (moveResult.isStalemate) {
                    status = t.stalemate;
                    statusClass = 'status-ended';
                    messageEl.textContent = status;
                    overlay.style.display = 'flex';
                } else if (moveResult.isDraw) {
                    status = moveResult.gameStatus === 'draw-repetition' ? 
                        t.drawRepetition : t.drawFifty;
                    statusClass = 'status-ended';
                    messageEl.textContent = status;
                    overlay.style.display = 'flex';
                } else if (moveResult.isCheck) {
                    status = t.check;
                }
            }

            // If game is still active, show regular turn status
            if (!status) {
                if (gameMode === 'multiplayer' && gameStarted && playerColor) {
                    const isMyTurn = (game.turn === 'w' && playerColor === 'white') || 
                                   (game.turn === 'b' && playerColor === 'black');
                    status = isMyTurn ? t.yourTurn : t.opponentTurn;
                } else if (gameMode === 'single') {
                    status = game.turn === 'w' ? t.whitesTurn : t.blacksTurn;
                }
            }
            
            // Update the status display
            const statusElement = document.getElementById('game-status');
            statusElement.textContent = status;
            statusElement.className = `game-status ${statusClass}`;

            // Update active player highlight
            if (gameStarted) {
                document.getElementById('white-player').classList.toggle('active', game.turn === 'w');
                document.getElementById('black-player').classList.toggle('active', game.turn === 'b');
            }
        }

        // Add move to history
        function addToHistory(move) {
            const historyList = document.getElementById('history-list');
            const moveElement = document.createElement('div');
            moveElement.textContent = `${Math.ceil(game.history.length / 2)}. ${move}`;
            moveElement.style.padding = '2px 5px';
            moveElement.style.borderBottom = '1px solid #eee';
            historyList.appendChild(moveElement);
            historyList.scrollTop = historyList.scrollHeight;
        }

        // Start new game
        function startNewGame() {
            game.reset();
            clearSelection();
            document.getElementById('history-list').innerHTML = '';
            createBoard();
            
            if (gameMode === 'multiplayer' && socket) {
                socket.disconnect();
                // Reconnect and rejoin lobby
                socket = io();
                initMultiplayer();
            } else {
                gameStarted = true;
                updateStatus();
            }
        }

        // Go to home page
        function goHome() {
            if (socket) {
                socket.disconnect();
            }
            window.location.href = `/?lang=${currentLang}`;
        }

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (socket) {
                socket.disconnect();
            }
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>